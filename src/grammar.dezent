// This is the grammar for dezent grammars -
// the dezent parser uses this grammar to parse grammar
// documents prior to parsing.

return _ ( { returnSt | defineSt } _ )* 
	-> $1;

_ = ( singleLineComment | multiLineComment | whitespace )* -> null;

singleLineComment = '//' /[^\n]*\n/     -> null;
multiLineComment  = '/*' /(.|\n)*/ '*/' -> null;
whitespace        = /\s*/               -> null;

returnSt = 'return' /\s+/ {rule} _ ';' 
	-> { type: 'return', rule: $1 };

defineSt = {identifier} _ '=' _ {rule} ( _ ',' _ {rule} )* _ ';' 
	-> { type: 'define', name: $1, rules: [$2, ...$3] };

rule = {template} _ '->' _ {value} 
	-> { type: 'rule', ...$1, value: $2 };

template = {templateOption} _ ( '|' _ {templateOption} _ )* 
	-> { options: [$1, ...$2] };

templateOption = ( { capture | group | stringToken | regex | class | ruleref | any } _ )*
	-> { type: 'option', tokens: $1 };

capture = {predicate} '{' _ {captureTemplate} _ '}' {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: { type: 'capture', ...$2 } };

group = {predicate} '(' _ {template} _ ')' {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: { type: 'group', ...$2 } };

captureTemplate = {captureTemplateOption} _ ( '|' _ {captureTemplateOption} _ )+
	-> { options: [$1, ...$2] };

captureTemplateOption = ( { captureGroup | stringToken | regex | class | ruleref | any } _ )*
	-> { type: 'option', tokens: $1 };

captureGroup = '(' _ {captureTemplate} _ ')' {repeat}?
	-> { type: 'group', ...$1, repeat: $2 };

regex = {predicate} '/' { /([^\\\\\\/]|\\\\.)*/ } '/' {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: { type: 'regex', pattern: $2 } };

class = {predicate} '[' { classComponent }* ']' {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: { type: "class", ranges: $1 } };

classComponent =
	{classChar} '-' {classChar} -> [$1, $2],
	{classChar} -> [$1, $1];

classChar = !']' {.} -> $1;

any = {predicate} '.' {modifier} -> { type: 'token', ...$2, ...$1, descriptor: { type: "any" } };

stringToken = {predicate} {string} {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: $2 };

ruleref = {predicate} {identifier} {modifier}
	-> {type: 'token', ...$3, ...$1, descriptor: { type: 'ruleref', name: $2 } };

predicate =
	'&' -> { and: true, not: false },
	'!' -> { and: false, not: true },
	''  -> { and: false, not: false };

modifier = 
	'*' -> { repeat: true, required: false },
	'+' -> { repeat: true, required: true },
	'?' -> { repeat: false, required: false },
	''  -> { repeat: false, required: true };

value = { backref | object | array | string | number | boolean | null } 
	-> $1;

backref = '$' { /\d+/ } 
	-> { type: 'backref', index: $1 };

splat = 
	'...' {backref} -> { type: 'splat', backrefs: [$1] },
	'...(' _ {backref} ( _ ',' _ {backref} )* _ ')' -> { type: 'splat', backrefs: [$1, ...$2] };

object = '{' ( _ {member} _ ',' )* _ {member}? _ '}' 
	-> { type: 'object', members: [...$1, $2] };

member = 
	{splat} -> $1,
	{backref|string|identifierAsStringNode} _ ':' _ {value} -> { name: $1, value: $2 };

array = '[' ( _ {value|splat} _ ',' )* _ {value|splat}? _ ']' 
	-> { type: 'array', elements: [...$1, $2] };

string = /'/ {escape|stringText}* /'/ 
	-> { type: 'string', tokens: $1 };

stringText = { /[^'\\\n]+/ } 
	-> { type: 'text', value: $1 };

number = 
	{ /-?\d+(\.\d+)?([eE][-+]\d+)?/ } -> { type: 'number', value: $1 },
	{ /-?\.\d+([eE][-+]\d+)?/ } -> { type: 'number', value: $1 };

boolean =
	'true'  -> { type: 'boolean', value: true },
	'false' -> { type: 'boolean', value: false };

null = 'null' 
	-> { type: 'null' };

escape = '\\' { /(u[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]|[^\n])/ }
	-> { type: 'escape', value: $1 };

identifier = { /[_a-zA-Z][_a-zA-Z0-9]*/ }
	-> $1;

identifierAsStringNode = {identifier}
	-> { type: 'string', tokens: [ {type: 'text', value: $1 } ] }
