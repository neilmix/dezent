/*
 *  Dezent - Powerful pattern matching and parsing that's readable, recursive, and structured.
 *  Copyright (C) 2020  Neil Mix  <neilmix@gmail.com>
 *  Commercial licensing and support are available, please contact neilmix@gmail.com.
 * 
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>. 
 */

// This is the grammar for dezent grammars -
// the dezent parser uses this grammar to parse grammar
// documents prior to parsing.

return _ ( {returndef|ruleset} _ | {constant} _ )* 
	-> { ruleset: $1, vars: { ...$2 } };

_ = ( singleLineComment | multiLineComment | whitespace? )* -> void;

singleLineComment = '//' ( !'\n' . )* '\n' -> void;
multiLineComment  = '/*' ( !'*/' . )* '*/' -> void;
whitespace        = [\u0020\t-\r]+ -> void;

returndef = 'return' whitespace _ {rule} _ ';' 
	-> { type: 'ruleset', name: 'return', rules: [$1], ...$meta };

ruleset = {identifier} _ '=' _ {rule} ( _ ',' _ {rule} )* _ ';' 
	-> { type: 'ruleset', name: $1, rules: [$2, ...$3], ...$meta };

constant = '$' {identifier} _ '=' _ {value} _ ';'
	-> [$1, $2];

rule = {options} _ '->' _ {value} 
	-> { type: 'rule', ...$1, value: $2, ...$meta };

options = {pattern} _ ( '|' _ {pattern} _ )* 
	-> { options: [$1, ...$2] };

pattern = ( { token } _ )+
	-> { type: 'pattern', tokens: $1 };

token = {predicate} { capture | group | string | class | ruleref | any } {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: $2 };

capture = '{' _ {captureOptions} _ '}'
	-> { type: 'capture', ...$1 };

group = '(' _ {options} _ ')'
	-> { type: 'group', ...$1 };

captureOptions = {capturePattern} _ ( '|' _ {capturePattern} _ )*
	-> { options: [$1, ...$2] };

capturePattern = ( { captureToken } _ )+
	-> { type: 'pattern', tokens: $1 };

captureToken = {predicate} { captureGroup | string | class | ruleref | any } {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: $2 };
	
captureGroup = '(' _ {captureOptions} _ ')'
	-> { type: 'group', ...$1 };

class = '[' { classComponent }* ']'
	-> { type: 'class', ranges: $1 };

classComponent =
	{classChar} '-' {classChar} -> [$1, $2],
	{classChar} -> [$1, $1];

classChar = !']' {escape|char} 
	-> $1;

char = charstr
	-> { type: 'char', value: $0 };

any = '.'
	-> { type: 'any' };

ruleref = {identifier}
	-> { type: 'ruleref', name: $1, ...$meta };

predicate =
	'&' -> { and: true, not: false },
	'!' -> { and: false, not: true },
	''  -> { and: false, not: false };

modifier = 
	'*' -> { repeat: true, required: false },
	'+' -> { repeat: true, required: true },
	'?' -> { repeat: false, required: false },
	''  -> { repeat: false, required: true };

value = { backref | constref | metaref | pivot | object | array | string | number | boolean | null | void } 
	-> $1;

backref = 
	'$' { [0-9]+ } '?' {access} -> { type: 'backref', index: $1, collapse: true, access: $2, ...$meta },
	'$' { [0-9]+ } {access} -> { type: 'backref', index: $1, collapse: false, access: $2, ...$meta };

constref = '$' { identifier } {access}
	-> { type: 'constref', name: $1, access: $2, ...$meta };

metaref = '@' { 'position' | 'length' }
	-> { type: 'metaref', name: $1 };

pivot = '^' {backref|constref|array|pivot}
	-> { type: 'pivot', value: $1, ...$meta };

spread = '...' {backref|constref|pivot|object|array|string} 
	-> { type: 'spread', value: $1, ...$meta };

object = '{' ( _ {member} _ ',' )* _ {member}? _ '}' {access}
	-> { type: 'object', members: [...$1, $2?], access: $3 };

member = 
	{spread} -> $1,
	{backref|string|identifierAsStringNode} _ ':' _ {value} -> { type: 'member', name: $1, value: $2 };

array = '[' ( _ {element} _ ',' )* _ {element}? _ ']' {access}
	-> { type: 'array', elements: [...$1, $2?], access: $3 };

element = {value|spread} 
	-> $1;

string = '\'' {escape|stringText}* '\''
	-> { type: 'string', tokens: $1 };

stringText = ( !['\\] . )+
	-> { type: 'text', value: $0 };

number = 
	'-'? ( [0-9]+ )? '.' [0-9]+  ( [eE] [-+] [0-9]+ )? -> { type: 'number', value: $0 },
	'-'? [0-9]+  ( [eE] [-+] [0-9]+ )? -> { type: 'number', value: $0 };

boolean =
	'true'  -> { type: 'boolean', value: true },
	'false' -> { type: 'boolean', value: false };

null = 'null' 
	-> { type: 'null' };

void = 'void'
	-> { type: 'void' };

access = {dotAccess|bracketAccess}* 
	-> $1;

dotAccess = '.' {identifier} 
	-> { name: $1, ...$meta };

bracketAccess = '[' _ {backref|constref|metaref|string|index} _ ']' 
	-> { value: $1, ...$meta };

index = [0-9]+
	-> { type: 'number', value: $0 };

escape = '\\' { unicode | charstr }
	-> { type: 'escape', value: $1 };

unicode = 'u' [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9]
	-> $0;

charstr = !'\n' .
	-> $0;

identifier = [_a-zA-Z] [_a-zA-Z0-9]*
	-> $0;

identifierAsStringNode = {identifier}
	-> { type: 'string', tokens: [ {type: 'text', value: $1 } ] };

$meta = { meta: { pos: @position, length: @length } };
