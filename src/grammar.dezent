// This is the grammar for dezent grammars -
// the dezent parser uses this grammar to parse grammar
// documents prior to parsing.

return _ ( { returnSt | defineSt } _ )* 
	-> $1;

_ = ( singleLineComment | multiLineComment | whitespace? )* -> null;

singleLineComment = '//' ( !'\n' . )* '\n' -> null;
multiLineComment  = '/*' ( !'*/' . )* '*/' -> null;
whitespace        = [\u0020\t-\r]+ -> null;

returnSt = 'return' whitespace {rule} _ ';' 
	-> { type: 'return', rule: $1 };

defineSt = {identifier} _ '=' _ {rule} ( _ ',' _ {rule} )* _ ';' 
	-> { type: 'define', name: $1, rules: [$2, ...$3] };

rule = {options} _ '->' _ {value} 
	-> { type: 'rule', ...$1, value: $2 };

options = {pattern} _ ( '|' _ {pattern} _ )* 
	-> { options: [$1, ...$2] };

pattern = ( { capture | group | stringToken | class | ruleref | any } _ )+
	-> { type: 'pattern', tokens: $1 };

capture = {predicate} '{' _ {captureOptions} _ '}' {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: { type: 'capture', ...$2 } };

group = {predicate} '(' _ {options} _ ')' {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: { type: 'group', ...$2 } };

captureOptions = {capturePattern} _ ( '|' _ {capturePattern} _ )*
	-> { options: [$1, ...$2] };

capturePattern = ( { captureGroup | stringToken | class | ruleref | any } _ )+
	-> { type: 'pattern', tokens: $1 };

captureGroup = {predicate} '(' _ {captureOptions} _ ')' {modifier}?
	-> { type: 'token', ...$3, ...$1, descriptor: { type: 'group', ...$2 } };

class = {predicate} '[' { classComponent }* ']' {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: { type: 'class', ranges: $2 } };

classComponent =
	{classChar} '-' {classChar} -> [$1, $2],
	{classChar} -> [$1, $1];

classChar = !']' {escape|char} 
	-> $1;

char = charstr
	-> { type: 'char', value: $0 };

any = {predicate} '.' {modifier} 
	-> { type: 'token', ...$2, ...$1, descriptor: { type: 'any' } };

stringToken = {predicate} {string} {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: $2 };

ruleref = {predicate} {identifier} {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: { type: 'ruleref', name: $2 } };

predicate =
	'&' -> { and: true, not: false },
	'!' -> { and: false, not: true },
	''  -> { and: false, not: false };

modifier = 
	'*' -> { repeat: true, required: false },
	'+' -> { repeat: true, required: true },
	'?' -> { repeat: false, required: false },
	''  -> { repeat: false, required: true };

value = { backref | object | array | string | number | boolean | null } 
	-> $1;

backref = '$' { [0-9]+ } 
	-> { type: 'backref', index: $1 };

splat = 
	'...' {backref} -> { type: 'splat', backrefs: [$1] },
	'...(' _ {backref} ( _ ',' _ {backref} )* _ ')' -> { type: 'splat', backrefs: [$1, ...$2] };

object = '{' ( _ {member} _ ',' )* _ {member}? _ '}' 
	-> { type: 'object', members: [...$1, $2] };

member = 
	{splat} -> $1,
	{backref|string|identifierAsStringNode} _ ':' _ {value} -> { type: 'member', name: $1, value: $2 };

array = '[' ( _ {value|splat} _ ',' )* _ {value|splat}? _ ']' 
	-> { type: 'array', elements: [...$1, $2] };

string = '\'' {escape|stringText}* '\''
	-> { type: 'string', tokens: $1 };

stringText = ( !['\\] . )+
	-> { type: 'text', value: $0 };

number = 
	'-'? ( [0-9]+ )? '.' [0-9]+  ( [eE] [-+] [0-9]+ )? -> { type: 'number', value: $0 },
	'-'? [0-9]+  ( [eE] [-+] [0-9]+ )? -> { type: 'number', value: $0 };

boolean =
	'true'  -> { type: 'boolean', value: true },
	'false' -> { type: 'boolean', value: false };

null = 'null' 
	-> { type: 'null' };

escape = '\\' { unicode | charstr }
	-> { type: 'escape', value: $1 };

unicode = 'u' [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9]
	-> $0;

charstr = !'\n' .
	-> $0;

identifier = [_a-zA-Z] [_a-zA-Z0-9]*
	-> $0;

identifierAsStringNode = {identifier}
	-> { type: 'string', tokens: [ {type: 'text', value: $1 } ] };
