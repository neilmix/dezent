// This is the grammar for dezent grammars -
// the dezent parser uses this grammar to parse grammar
// documents prior to parsing.

return _ ( {returndef|ruledef} _ | '$' {identifier} _ '=' _ {value} _ ';' _ )* 
	-> { ruledefs: $1, vars: { ...($2, $3) } };

_ = ( singleLineComment | multiLineComment | whitespace? )* -> null;

singleLineComment = '//' ( !'\n' . )* '\n' -> null;
multiLineComment  = '/*' ( !'*/' . )* '*/' -> null;
whitespace        = [\u0020\t-\r]+ -> null;

returndef = 'return' whitespace _ {rule} _ ';' 
	-> { type: 'ruledef', name: 'return', rules: [$1] };

ruledef = {identifier} _ '=' _ {rule} ( _ ',' _ {rule} )* _ ';' 
	-> { type: 'ruledef', name: $1, rules: [$2, ...$3] };

rule = {options} _ '->' _ {value} 
	-> { type: 'rule', ...$1, value: $2 };

options = {pattern} _ ( '|' _ {pattern} _ )* 
	-> { options: [$1, ...$2] };

pattern = ( { token } _ )+
	-> { type: 'pattern', tokens: $1 };

token = {predicate} { capture | group | string | class | ruleref | any } {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: $2 };

capture = '{' _ {captureOptions} _ '}'
	-> { type: 'capture', ...$1 };

group = '(' _ {options} _ ')'
	-> { type: 'group', ...$1 };

captureOptions = {capturePattern} _ ( '|' _ {capturePattern} _ )*
	-> { options: [$1, ...$2] };

capturePattern = ( { captureToken } _ )+
	-> { type: 'pattern', tokens: $1 };

captureToken = {predicate} { captureGroup | string | class | ruleref | any } {modifier}
	-> { type: 'token', ...$3, ...$1, descriptor: $2 };
	
captureGroup = '(' _ {captureOptions} _ ')'
	-> { type: 'group', ...$1 };

class = '[' { classComponent }* ']'
	-> { type: 'class', ranges: $1 };

classComponent =
	{classChar} '-' {classChar} -> [$1, $2],
	{classChar} -> [$1, $1];

classChar = !']' {escape|char} 
	-> $1;

char = charstr
	-> { type: 'char', value: $0 };

any = '.'
	-> { type: 'any' };

ruleref = {identifier}
	-> { type: 'ruleref', name: $1 };

predicate =
	'&' -> { and: true, not: false },
	'!' -> { and: false, not: true },
	''  -> { and: false, not: false };

modifier = 
	'*' -> { repeat: true, required: false },
	'+' -> { repeat: true, required: true },
	'?' -> { repeat: false, required: false },
	''  -> { repeat: false, required: true };

value = { backref | varref | metaref | object | array | string | number | boolean | null } 
	-> $1;

backref = '$' { [0-9]+ } 
	-> { type: 'backref', index: $1 };

varref = '$' { identifier }
	-> { type: 'varref', name: $1 };

metaref = '@' { 'position' | 'length' }
	-> { type: 'metaref', name: $1 };

splat = 
	'...' {backref} -> { type: 'splat', backrefs: [$1] },
	'...(' _ {backref} ( _ ',' _ {backref} )* _ ')' -> { type: 'splat', backrefs: [$1, ...$2] };

object = '{' ( _ {member} _ ',' )* _ {member}? _ '}' 
	-> { type: 'object', members: [...$1, $2] };

member = 
	{splat} -> $1,
	{backref|string|identifierAsStringNode} _ ':' _ {value} -> { type: 'member', name: $1, value: $2 };

array = '[' ( _ {value|splat} _ ',' )* _ {value|splat}? _ ']' 
	-> { type: 'array', elements: [...$1, $2] };

string = '\'' {escape|stringText}* '\''
	-> { type: 'string', tokens: $1 };

stringText = ( !['\\] . )+
	-> { type: 'text', value: $0 };

number = 
	'-'? ( [0-9]+ )? '.' [0-9]+  ( [eE] [-+] [0-9]+ )? -> { type: 'number', value: $0 },
	'-'? [0-9]+  ( [eE] [-+] [0-9]+ )? -> { type: 'number', value: $0 };

boolean =
	'true'  -> { type: 'boolean', value: true },
	'false' -> { type: 'boolean', value: false };

null = 'null' 
	-> { type: 'null' };

escape = '\\' { unicode | charstr }
	-> { type: 'escape', value: $1 };

unicode = 'u' [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9]
	-> $0;

charstr = !'\n' .
	-> $0;

identifier = [_a-zA-Z] [_a-zA-Z0-9]*
	-> $0;

identifierAsStringNode = {identifier}
	-> { type: 'string', tokens: [ {type: 'text', value: $1 } ] };
